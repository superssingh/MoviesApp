{"ast":null,"code":"/**\n * @license\n * Copyright 2020 Google Inc.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\nimport { normalizeKey } from '@material/dom/keyboard';\nimport { numbers } from './constants';\nimport { preventDefaultEvent } from './events';\n/**\n * Initializes a state object for typeahead. Use the same reference for calls to\n * typeahead functions.\n *\n * @return The current state of the typeahead process. Each state reference\n *     represents a typeahead instance as the reference is typically mutated\n *     in-place.\n */\n\nexport function initState() {\n  var state = {\n    bufferClearTimeout: 0,\n    currentFirstChar: '',\n    sortedIndexCursor: 0,\n    typeaheadBuffer: ''\n  };\n  return state;\n}\n/**\n * Initializes typeahead state by indexing the current list items by primary\n * text into the sortedIndexByFirstChar data structure.\n *\n * @param listItemCount numer of items in the list\n * @param getPrimaryTextByItemIndex function that returns the primary text at a\n *     given index\n *\n * @return Map that maps the first character of the primary text to the full\n *     list text and it's index\n */\n\nexport function initSortedIndex(listItemCount, getPrimaryTextByItemIndex) {\n  var sortedIndexByFirstChar = new Map(); // Aggregate item text to index mapping\n\n  for (var i = 0; i < listItemCount; i++) {\n    var primaryText = getPrimaryTextByItemIndex(i).trim();\n\n    if (!primaryText) {\n      continue;\n    }\n\n    var firstChar = primaryText[0].toLowerCase();\n\n    if (!sortedIndexByFirstChar.has(firstChar)) {\n      sortedIndexByFirstChar.set(firstChar, []);\n    }\n\n    sortedIndexByFirstChar.get(firstChar).push({\n      text: primaryText.toLowerCase(),\n      index: i\n    });\n  } // Sort the mapping\n  // TODO(b/157162694): Investigate replacing forEach with Map.values()\n\n\n  sortedIndexByFirstChar.forEach(function (values) {\n    values.sort(function (first, second) {\n      return first.index - second.index;\n    });\n  });\n  return sortedIndexByFirstChar;\n}\n/**\n * Given the next desired character from the user, it attempts to find the next\n * list option matching the buffer. Wraps around if at the end of options.\n *\n * @param opts Options and accessors\n *   - nextChar - the next character to match against items\n *   - sortedIndexByFirstChar - output of `initSortedIndex(...)`\n *   - focusedItemIndex - the index of the currently focused item\n *   - focusItemAtIndex - function that focuses a list item at given index\n *   - skipFocus - whether or not to focus the matched item\n *   - isItemAtIndexDisabled - function that determines whether an item at a\n *        given index is disabled\n * @param state The typeahead state instance. See `initState`.\n *\n * @return The index of the matched item, or -1 if no match.\n */\n\nexport function matchItem(opts, state) {\n  var nextChar = opts.nextChar,\n      focusItemAtIndex = opts.focusItemAtIndex,\n      sortedIndexByFirstChar = opts.sortedIndexByFirstChar,\n      focusedItemIndex = opts.focusedItemIndex,\n      skipFocus = opts.skipFocus,\n      isItemAtIndexDisabled = opts.isItemAtIndexDisabled;\n  clearTimeout(state.bufferClearTimeout);\n  state.bufferClearTimeout = setTimeout(function () {\n    clearBuffer(state);\n  }, numbers.TYPEAHEAD_BUFFER_CLEAR_TIMEOUT_MS);\n  state.typeaheadBuffer = state.typeaheadBuffer + nextChar;\n  var index;\n\n  if (state.typeaheadBuffer.length === 1) {\n    index = matchFirstChar(sortedIndexByFirstChar, focusedItemIndex, isItemAtIndexDisabled, state);\n  } else {\n    index = matchAllChars(sortedIndexByFirstChar, isItemAtIndexDisabled, state);\n  }\n\n  if (index !== -1 && !skipFocus) {\n    focusItemAtIndex(index);\n  }\n\n  return index;\n}\n/**\n * Matches the user's single input character in the buffer to the\n * next option that begins with such character. Wraps around if at\n * end of options. Returns -1 if no match is found.\n */\n\nfunction matchFirstChar(sortedIndexByFirstChar, focusedItemIndex, isItemAtIndexDisabled, state) {\n  var firstChar = state.typeaheadBuffer[0];\n  var itemsMatchingFirstChar = sortedIndexByFirstChar.get(firstChar);\n\n  if (!itemsMatchingFirstChar) {\n    return -1;\n  } // Has the same firstChar been recently matched?\n  // Also, did starting index remain the same between key presses?\n  // If both hold true, simply increment index.\n\n\n  if (firstChar === state.currentFirstChar && itemsMatchingFirstChar[state.sortedIndexCursor].index === focusedItemIndex) {\n    state.sortedIndexCursor = (state.sortedIndexCursor + 1) % itemsMatchingFirstChar.length;\n    var newIndex = itemsMatchingFirstChar[state.sortedIndexCursor].index;\n\n    if (!isItemAtIndexDisabled(newIndex)) {\n      return newIndex;\n    }\n  } // If we're here, it means one of the following happened:\n  // - either firstChar or startingIndex has changed, invalidating the\n  // cursor.\n  // - The next item of typeahead is disabled, so we have to look further.\n\n\n  state.currentFirstChar = firstChar;\n  var newCursorPosition = -1;\n  var cursorPosition; // Find the first non-disabled item as a fallback.\n\n  for (cursorPosition = 0; cursorPosition < itemsMatchingFirstChar.length; cursorPosition++) {\n    if (!isItemAtIndexDisabled(itemsMatchingFirstChar[cursorPosition].index)) {\n      newCursorPosition = cursorPosition;\n      break;\n    }\n  } // Advance cursor to first item matching the firstChar that is positioned\n  // after starting item. Cursor is unchanged from fallback if there's no\n  // such item.\n\n\n  for (; cursorPosition < itemsMatchingFirstChar.length; cursorPosition++) {\n    if (itemsMatchingFirstChar[cursorPosition].index > focusedItemIndex && !isItemAtIndexDisabled(itemsMatchingFirstChar[cursorPosition].index)) {\n      newCursorPosition = cursorPosition;\n      break;\n    }\n  }\n\n  if (newCursorPosition !== -1) {\n    state.sortedIndexCursor = newCursorPosition;\n    return itemsMatchingFirstChar[state.sortedIndexCursor].index;\n  }\n\n  return -1;\n}\n/**\n * Attempts to find the next item that matches all of the typeahead buffer.\n * Wraps around if at end of options. Returns -1 if no match is found.\n */\n\n\nfunction matchAllChars(sortedIndexByFirstChar, isItemAtIndexDisabled, state) {\n  var firstChar = state.typeaheadBuffer[0];\n  var itemsMatchingFirstChar = sortedIndexByFirstChar.get(firstChar);\n\n  if (!itemsMatchingFirstChar) {\n    return -1;\n  } // Do nothing if text already matches\n\n\n  var startingItem = itemsMatchingFirstChar[state.sortedIndexCursor];\n\n  if (startingItem.text.lastIndexOf(state.typeaheadBuffer, 0) === 0 && !isItemAtIndexDisabled(startingItem.index)) {\n    return startingItem.index;\n  } // Find next item that matches completely; if no match, we'll eventually\n  // loop around to same position\n\n\n  var cursorPosition = (state.sortedIndexCursor + 1) % itemsMatchingFirstChar.length;\n  var nextCursorPosition = -1;\n\n  while (cursorPosition !== state.sortedIndexCursor) {\n    var currentItem = itemsMatchingFirstChar[cursorPosition];\n    var matches = currentItem.text.lastIndexOf(state.typeaheadBuffer, 0) === 0;\n    var isEnabled = !isItemAtIndexDisabled(currentItem.index);\n\n    if (matches && isEnabled) {\n      nextCursorPosition = cursorPosition;\n      break;\n    }\n\n    cursorPosition = (cursorPosition + 1) % itemsMatchingFirstChar.length;\n  }\n\n  if (nextCursorPosition !== -1) {\n    state.sortedIndexCursor = nextCursorPosition;\n    return itemsMatchingFirstChar[state.sortedIndexCursor].index;\n  }\n\n  return -1;\n}\n/**\n * Whether or not the given typeahead instaance state is currently typing.\n *\n * @param state The typeahead state instance. See `initState`.\n */\n\n\nexport function isTypingInProgress(state) {\n  return state.typeaheadBuffer.length > 0;\n}\n/**\n * Clears the typeahaed buffer so that it resets item matching to the first\n * character.\n *\n * @param state The typeahead state instance. See `initState`.\n */\n\nexport function clearBuffer(state) {\n  state.typeaheadBuffer = '';\n}\n/**\n * Given a keydown event, it calculates whether or not to automatically focus a\n * list item depending on what was typed mimicing the typeahead functionality of\n * a standard <select> element that is open.\n *\n * @param opts Options and accessors\n *   - event - the KeyboardEvent to handle and parse\n *   - sortedIndexByFirstChar - output of `initSortedIndex(...)`\n *   - focusedItemIndex - the index of the currently focused item\n *   - focusItemAtIndex - function that focuses a list item at given index\n *   - isItemAtFocusedIndexDisabled - whether or not the currently focused item\n *      is disabled\n *   - isTargetListItem - whether or not the event target is a list item\n * @param state The typeahead state instance. See `initState`.\n *\n * @returns index of the item matched by the keydown. -1 if not matched.\n */\n\nexport function handleKeydown(opts, state) {\n  var event = opts.event,\n      isTargetListItem = opts.isTargetListItem,\n      focusedItemIndex = opts.focusedItemIndex,\n      focusItemAtIndex = opts.focusItemAtIndex,\n      sortedIndexByFirstChar = opts.sortedIndexByFirstChar,\n      isItemAtIndexDisabled = opts.isItemAtIndexDisabled;\n  var isArrowLeft = normalizeKey(event) === 'ArrowLeft';\n  var isArrowUp = normalizeKey(event) === 'ArrowUp';\n  var isArrowRight = normalizeKey(event) === 'ArrowRight';\n  var isArrowDown = normalizeKey(event) === 'ArrowDown';\n  var isHome = normalizeKey(event) === 'Home';\n  var isEnd = normalizeKey(event) === 'End';\n  var isEnter = normalizeKey(event) === 'Enter';\n  var isSpace = normalizeKey(event) === 'Spacebar';\n\n  if (event.ctrlKey || event.metaKey || isArrowLeft || isArrowUp || isArrowRight || isArrowDown || isHome || isEnd || isEnter) {\n    return -1;\n  }\n\n  var isCharacterKey = !isSpace && event.key.length === 1;\n\n  if (isCharacterKey) {\n    preventDefaultEvent(event);\n    var matchItemOpts = {\n      focusItemAtIndex: focusItemAtIndex,\n      focusedItemIndex: focusedItemIndex,\n      nextChar: event.key.toLowerCase(),\n      sortedIndexByFirstChar: sortedIndexByFirstChar,\n      skipFocus: false,\n      isItemAtIndexDisabled: isItemAtIndexDisabled\n    };\n    return matchItem(matchItemOpts, state);\n  }\n\n  if (!isSpace) {\n    return -1;\n  }\n\n  if (isTargetListItem) {\n    preventDefaultEvent(event);\n  }\n\n  var typeaheadOnListItem = isTargetListItem && isTypingInProgress(state);\n\n  if (typeaheadOnListItem) {\n    var matchItemOpts = {\n      focusItemAtIndex: focusItemAtIndex,\n      focusedItemIndex: focusedItemIndex,\n      nextChar: ' ',\n      sortedIndexByFirstChar: sortedIndexByFirstChar,\n      skipFocus: false,\n      isItemAtIndexDisabled: isItemAtIndexDisabled\n    }; // space participates in typeahead matching if in rapid typing mode\n\n    return matchItem(matchItemOpts, state);\n  }\n\n  return -1;\n}","map":{"version":3,"sources":["typeahead.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\n * @license\n * Copyright 2020 Google Inc.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\nimport { normalizeKey } from '@material/dom/keyboard';\nimport { numbers } from './constants';\nimport { preventDefaultEvent } from './events';\n/**\n * Initializes a state object for typeahead. Use the same reference for calls to\n * typeahead functions.\n *\n * @return The current state of the typeahead process. Each state reference\n *     represents a typeahead instance as the reference is typically mutated\n *     in-place.\n */\nexport function initState() {\n    var state = {\n        bufferClearTimeout: 0,\n        currentFirstChar: '',\n        sortedIndexCursor: 0,\n        typeaheadBuffer: '',\n    };\n    return state;\n}\n/**\n * Initializes typeahead state by indexing the current list items by primary\n * text into the sortedIndexByFirstChar data structure.\n *\n * @param listItemCount numer of items in the list\n * @param getPrimaryTextByItemIndex function that returns the primary text at a\n *     given index\n *\n * @return Map that maps the first character of the primary text to the full\n *     list text and it's index\n */\nexport function initSortedIndex(listItemCount, getPrimaryTextByItemIndex) {\n    var sortedIndexByFirstChar = new Map();\n    // Aggregate item text to index mapping\n    for (var i = 0; i < listItemCount; i++) {\n        var primaryText = getPrimaryTextByItemIndex(i).trim();\n        if (!primaryText) {\n            continue;\n        }\n        var firstChar = primaryText[0].toLowerCase();\n        if (!sortedIndexByFirstChar.has(firstChar)) {\n            sortedIndexByFirstChar.set(firstChar, []);\n        }\n        sortedIndexByFirstChar.get(firstChar).push({ text: primaryText.toLowerCase(), index: i });\n    }\n    // Sort the mapping\n    // TODO(b/157162694): Investigate replacing forEach with Map.values()\n    sortedIndexByFirstChar.forEach(function (values) {\n        values.sort(function (first, second) {\n            return first.index - second.index;\n        });\n    });\n    return sortedIndexByFirstChar;\n}\n/**\n * Given the next desired character from the user, it attempts to find the next\n * list option matching the buffer. Wraps around if at the end of options.\n *\n * @param opts Options and accessors\n *   - nextChar - the next character to match against items\n *   - sortedIndexByFirstChar - output of `initSortedIndex(...)`\n *   - focusedItemIndex - the index of the currently focused item\n *   - focusItemAtIndex - function that focuses a list item at given index\n *   - skipFocus - whether or not to focus the matched item\n *   - isItemAtIndexDisabled - function that determines whether an item at a\n *        given index is disabled\n * @param state The typeahead state instance. See `initState`.\n *\n * @return The index of the matched item, or -1 if no match.\n */\nexport function matchItem(opts, state) {\n    var nextChar = opts.nextChar, focusItemAtIndex = opts.focusItemAtIndex, sortedIndexByFirstChar = opts.sortedIndexByFirstChar, focusedItemIndex = opts.focusedItemIndex, skipFocus = opts.skipFocus, isItemAtIndexDisabled = opts.isItemAtIndexDisabled;\n    clearTimeout(state.bufferClearTimeout);\n    state.bufferClearTimeout = setTimeout(function () {\n        clearBuffer(state);\n    }, numbers.TYPEAHEAD_BUFFER_CLEAR_TIMEOUT_MS);\n    state.typeaheadBuffer = state.typeaheadBuffer + nextChar;\n    var index;\n    if (state.typeaheadBuffer.length === 1) {\n        index = matchFirstChar(sortedIndexByFirstChar, focusedItemIndex, isItemAtIndexDisabled, state);\n    }\n    else {\n        index = matchAllChars(sortedIndexByFirstChar, isItemAtIndexDisabled, state);\n    }\n    if (index !== -1 && !skipFocus) {\n        focusItemAtIndex(index);\n    }\n    return index;\n}\n/**\n * Matches the user's single input character in the buffer to the\n * next option that begins with such character. Wraps around if at\n * end of options. Returns -1 if no match is found.\n */\nfunction matchFirstChar(sortedIndexByFirstChar, focusedItemIndex, isItemAtIndexDisabled, state) {\n    var firstChar = state.typeaheadBuffer[0];\n    var itemsMatchingFirstChar = sortedIndexByFirstChar.get(firstChar);\n    if (!itemsMatchingFirstChar) {\n        return -1;\n    }\n    // Has the same firstChar been recently matched?\n    // Also, did starting index remain the same between key presses?\n    // If both hold true, simply increment index.\n    if (firstChar === state.currentFirstChar &&\n        itemsMatchingFirstChar[state.sortedIndexCursor].index ===\n            focusedItemIndex) {\n        state.sortedIndexCursor =\n            (state.sortedIndexCursor + 1) % itemsMatchingFirstChar.length;\n        var newIndex = itemsMatchingFirstChar[state.sortedIndexCursor].index;\n        if (!isItemAtIndexDisabled(newIndex)) {\n            return newIndex;\n        }\n    }\n    // If we're here, it means one of the following happened:\n    // - either firstChar or startingIndex has changed, invalidating the\n    // cursor.\n    // - The next item of typeahead is disabled, so we have to look further.\n    state.currentFirstChar = firstChar;\n    var newCursorPosition = -1;\n    var cursorPosition;\n    // Find the first non-disabled item as a fallback.\n    for (cursorPosition = 0; cursorPosition < itemsMatchingFirstChar.length; cursorPosition++) {\n        if (!isItemAtIndexDisabled(itemsMatchingFirstChar[cursorPosition].index)) {\n            newCursorPosition = cursorPosition;\n            break;\n        }\n    }\n    // Advance cursor to first item matching the firstChar that is positioned\n    // after starting item. Cursor is unchanged from fallback if there's no\n    // such item.\n    for (; cursorPosition < itemsMatchingFirstChar.length; cursorPosition++) {\n        if (itemsMatchingFirstChar[cursorPosition].index > focusedItemIndex &&\n            !isItemAtIndexDisabled(itemsMatchingFirstChar[cursorPosition].index)) {\n            newCursorPosition = cursorPosition;\n            break;\n        }\n    }\n    if (newCursorPosition !== -1) {\n        state.sortedIndexCursor = newCursorPosition;\n        return itemsMatchingFirstChar[state.sortedIndexCursor].index;\n    }\n    return -1;\n}\n/**\n * Attempts to find the next item that matches all of the typeahead buffer.\n * Wraps around if at end of options. Returns -1 if no match is found.\n */\nfunction matchAllChars(sortedIndexByFirstChar, isItemAtIndexDisabled, state) {\n    var firstChar = state.typeaheadBuffer[0];\n    var itemsMatchingFirstChar = sortedIndexByFirstChar.get(firstChar);\n    if (!itemsMatchingFirstChar) {\n        return -1;\n    }\n    // Do nothing if text already matches\n    var startingItem = itemsMatchingFirstChar[state.sortedIndexCursor];\n    if (startingItem.text.lastIndexOf(state.typeaheadBuffer, 0) === 0 &&\n        !isItemAtIndexDisabled(startingItem.index)) {\n        return startingItem.index;\n    }\n    // Find next item that matches completely; if no match, we'll eventually\n    // loop around to same position\n    var cursorPosition = (state.sortedIndexCursor + 1) % itemsMatchingFirstChar.length;\n    var nextCursorPosition = -1;\n    while (cursorPosition !== state.sortedIndexCursor) {\n        var currentItem = itemsMatchingFirstChar[cursorPosition];\n        var matches = currentItem.text.lastIndexOf(state.typeaheadBuffer, 0) === 0;\n        var isEnabled = !isItemAtIndexDisabled(currentItem.index);\n        if (matches && isEnabled) {\n            nextCursorPosition = cursorPosition;\n            break;\n        }\n        cursorPosition = (cursorPosition + 1) % itemsMatchingFirstChar.length;\n    }\n    if (nextCursorPosition !== -1) {\n        state.sortedIndexCursor = nextCursorPosition;\n        return itemsMatchingFirstChar[state.sortedIndexCursor].index;\n    }\n    return -1;\n}\n/**\n * Whether or not the given typeahead instaance state is currently typing.\n *\n * @param state The typeahead state instance. See `initState`.\n */\nexport function isTypingInProgress(state) {\n    return state.typeaheadBuffer.length > 0;\n}\n/**\n * Clears the typeahaed buffer so that it resets item matching to the first\n * character.\n *\n * @param state The typeahead state instance. See `initState`.\n */\nexport function clearBuffer(state) {\n    state.typeaheadBuffer = '';\n}\n/**\n * Given a keydown event, it calculates whether or not to automatically focus a\n * list item depending on what was typed mimicing the typeahead functionality of\n * a standard <select> element that is open.\n *\n * @param opts Options and accessors\n *   - event - the KeyboardEvent to handle and parse\n *   - sortedIndexByFirstChar - output of `initSortedIndex(...)`\n *   - focusedItemIndex - the index of the currently focused item\n *   - focusItemAtIndex - function that focuses a list item at given index\n *   - isItemAtFocusedIndexDisabled - whether or not the currently focused item\n *      is disabled\n *   - isTargetListItem - whether or not the event target is a list item\n * @param state The typeahead state instance. See `initState`.\n *\n * @returns index of the item matched by the keydown. -1 if not matched.\n */\nexport function handleKeydown(opts, state) {\n    var event = opts.event, isTargetListItem = opts.isTargetListItem, focusedItemIndex = opts.focusedItemIndex, focusItemAtIndex = opts.focusItemAtIndex, sortedIndexByFirstChar = opts.sortedIndexByFirstChar, isItemAtIndexDisabled = opts.isItemAtIndexDisabled;\n    var isArrowLeft = normalizeKey(event) === 'ArrowLeft';\n    var isArrowUp = normalizeKey(event) === 'ArrowUp';\n    var isArrowRight = normalizeKey(event) === 'ArrowRight';\n    var isArrowDown = normalizeKey(event) === 'ArrowDown';\n    var isHome = normalizeKey(event) === 'Home';\n    var isEnd = normalizeKey(event) === 'End';\n    var isEnter = normalizeKey(event) === 'Enter';\n    var isSpace = normalizeKey(event) === 'Spacebar';\n    if (event.ctrlKey || event.metaKey || isArrowLeft || isArrowUp ||\n        isArrowRight || isArrowDown || isHome || isEnd || isEnter) {\n        return -1;\n    }\n    var isCharacterKey = !isSpace && event.key.length === 1;\n    if (isCharacterKey) {\n        preventDefaultEvent(event);\n        var matchItemOpts = {\n            focusItemAtIndex: focusItemAtIndex,\n            focusedItemIndex: focusedItemIndex,\n            nextChar: event.key.toLowerCase(),\n            sortedIndexByFirstChar: sortedIndexByFirstChar,\n            skipFocus: false,\n            isItemAtIndexDisabled: isItemAtIndexDisabled,\n        };\n        return matchItem(matchItemOpts, state);\n    }\n    if (!isSpace) {\n        return -1;\n    }\n    if (isTargetListItem) {\n        preventDefaultEvent(event);\n    }\n    var typeaheadOnListItem = isTargetListItem && isTypingInProgress(state);\n    if (typeaheadOnListItem) {\n        var matchItemOpts = {\n            focusItemAtIndex: focusItemAtIndex,\n            focusedItemIndex: focusedItemIndex,\n            nextChar: ' ',\n            sortedIndexByFirstChar: sortedIndexByFirstChar,\n            skipFocus: false,\n            isItemAtIndexDisabled: isItemAtIndexDisabled,\n        };\n        // space participates in typeahead matching if in rapid typing mode\n        return matchItem(matchItemOpts, state);\n    }\n    return -1;\n}\n//# sourceMappingURL=typeahead.js.map"]},"metadata":{},"sourceType":"module"}